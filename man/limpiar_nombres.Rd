% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/limpiar_nombres.R
\encoding{UTF-8}
\name{limpiar_nombres}
\alias{limpiar_nombres}
\title{Limpia los nombres de un objeto (normalmente un data.frame).}
\usage{
limpiar_nombres(dat, ...)
}
\arguments{
\item{dat}{data.frame.}

\item{...}{
  Arguments passed on to \code{\link[=limpiar_nombres2]{limpiar_nombres2}}
  \describe{
    \item{\code{case}}{Preferencias de mayusculas}
    \item{\code{replace}}{Un vector de caracteres con nombre en el que el nombre se sustituye por el
value.}
    \item{\code{ascii}}{Convertir los nombres a ASCII (TRUE, por defecto) o no (FALSE).}
    \item{\code{use_make_names}}{¿Deberia aplicarse el codigo {make.names()} para asegurar que la
sea utilizable como un nombre sin comillas?  (Evitar \code{make.names()}
asegura que la salida es independiente de la localizacion, pero las comillas pueden ser necesarias).}
    \item{\code{sep_in}}{(short for separator input) if character, is interpreted as a
regular expression (wrapped internally into \code{stringr::regex()}). 
The default value is a regular expression that matches any sequence of
non-alphanumeric values. All matches will be replaced by underscores 
(additionally to \code{"_"} and \code{" "}, for which this is always true, even
if \code{NULL} is supplied). These underscores are used internally to split
the strings into substrings and specify the word boundaries.}
    \item{\code{parsing_option}}{An integer that will determine the parsing_option.
\itemize{
 \item{1: \code{"RRRStudio" -> "RRR_Studio"}}
 \item{2: \code{"RRRStudio" -> "RRRS_tudio"}}
 \item{3: \code{"RRRStudio" -> "RRRSStudio"}. This will become for example \code{"Rrrstudio"} when we convert to lower camel case.}
 \item{-1, -2, -3: These \code{parsing_options}'s will suppress the conversion after non-alphanumeric values.}
 \item{0: no parsing}
 }}
    \item{\code{transliterations}}{A character vector (if not \code{NULL}). The entries of this argument
need to be elements of \code{stringi::stri_trans_list()} (like "Latin-ASCII", which is often useful) or names of lookup tables (currently only "german" is supported). In the order of the entries the letters of the input
 string will be transliterated via \code{stringi::stri_trans_general()} or replaced via the 
 matches of the lookup table. When named character elements are supplied as part of `transliterations`, anything that matches the names is replaced by the corresponding value.
You should use this feature with care in case of \code{case = "parsed"}, \code{case = "internal_parsing"} and 
\code{case = "none"}, since for upper case letters, which have transliterations/replacements
 of length 2, the second letter will be transliterated to lowercase, for example Oe, Ae, Ss, which
 might not always be what is intended. In this case you can make usage of the option to supply named elements and specify the transliterations yourself.}
    \item{\code{numerals}}{A character specifying the alignment of numerals (\code{"middle"}, \code{left}, \code{right}, \code{asis} or \code{tight}). I.e. \code{numerals = "left"} ensures that no output separator is in front of a digit.}
  }}
}
\value{
Devuelve el data.frame con nombres limpios.
}
\description{
Los nombres resultantes son unicos y estan compuestos unicamente por el caracter \code{_}, numeros y
letras. Las preferencias de mayusculas se pueden especificar utilizando el parametro \code{case}.

Los caracteres acentuados se transliteran a ASCII.  Por ejemplo, una "o" con una
dieresis alemana sobre ella se convierte en "o", y el caracter español "ñ" se convierte en
"n".

Esta funcion toma y devuelve un data.frame. Se puede usar con pipelines
\code{`\%>\%`}. \code{limpiar_nombres} se basa en la versatil funcion
\code{link[snakecase]{to_any_case}}, que acepta muchos argumentos.  Consulte la documentacion de
esa funcion para obtener ideas sobre como sacar
sacar el maximo provecho de \code{limpiar_nombres}.  A continuacion se incluyen algunos ejemplos.

Esta funcion fue tomada del paquete janitor: \code{link[janitor]{clean_names}}.
}
\details{
\code{limpiar_nombres()} esta destinado a ser utilizado en \code{data.frames}
y objetos similares a un \code{data.frame}. Para limpiar otros objetos con nombre como listas con
nombre y vectores, use \code{limpiar_nombres2()}.
}
\examples{

# --- uso ---
#x <- data.frame(caseID = 1, DOB = 2, Other = 3)
#limpiar_nombres(x)

# o usando pipelines:
# x \%>\%
#  limpiar_nombres()

# si prefiere los nombres de las variables en camelCase:
#x \%>\%
 # limpiar_nombres(., "lower_camel")

# (not run) correr limpiar_nombres despues de cargar una base:
# library(readxl)
# read_excel("messy_excel_file.xlsx") \%>\%
#   limpiar_nombres()

# --- Aprovechando las ventajas de snakecase::to_any_case arguments ---

# Restaurar nombres de columnas para graficar
#mtcars \%>\%
#  limpiar_nombres(case = "title")

# indicar a limpiar_nombres dejar intactas ciertas abreviaturas:
#x \%>\%
#  limpiar_nombres(case = "upper_camel", abbreviations = c("ID", "DOB"))
}
\seealso{
Other Set names: 
\code{\link{mu_to_u}}
}
\concept{Set names}
