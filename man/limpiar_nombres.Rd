% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/limpiar_nombres.R
\encoding{UTF-8}
\name{limpiar_nombres}
\alias{limpiar_nombres}
\title{Limpia los nombres de un objeto (normalmente un data.frame).}
\usage{
limpiar_nombres(dat, ...)
}
\arguments{
\item{dat}{data.frame.}

\item{...}{
  Arguments passed on to \code{\link[=limpiar_nombres2]{limpiar_nombres2}}
  \describe{
    \item{\code{case}}{Preferencias de mayusculas}
    \item{\code{sep_in}}{(abreviatura de entrada separadora) si es un carácter, se interpreta como una expresión regular (envuelta internamente en stringr::regex()). El valor por defecto es una expresión regular que coincide con cualquier secuencia de valores no alfanuméricos. Todas las coincidencias serán reemplazadas por guiones bajos (además de "_" y " ", para los que esto siempre es cierto, incluso si se proporciona NULL). Estos guiones bajos se utilizan internamente para dividir las cadenas en subcadenas y especificar los límites de las palabras.}
    \item{\code{transliterations}}{Un vector de caracteres (si no es NULL). Las entradas de este argumento deben ser elementos de stringi::stri_trans_list() (como "Latin-ASCII", que suele ser útil) o nombres de tablas de búsqueda (actualmente sólo se admite "german").}
    \item{\code{parsing_option}}{Un entero que determinará la parsing_option.}
    \item{\code{numerals}}{Carácter que especifica la alineación de los numerales ("medio", izquierda, derecha, asis o apretado). Es decir, numerales = "izquierda" garantiza que no haya ningún separador de salida delante de un dígito.}
    \item{\code{replace}}{Un vector de caracteres con nombre en el que el nombre se sustituye por el
value.}
    \item{\code{ascii}}{Convertir los nombres a ASCII (TRUE, por defecto) o no (FALSE).}
    \item{\code{use_make_names}}{¿Deberia aplicarse el codigo {make.names()} para asegurar que la sea utilizable como un nombre sin comillas?  (Evitar \code{make.names()} asegura que la salida es independiente de la localizacion, pero las comillas pueden ser necesarias).}
  }}
}
\value{
Devuelve el data.frame con nombres limpios.
}
\description{
Los nombres resultantes son unicos y estan compuestos unicamente por el caracter \code{_}, numeros y
letras. Las preferencias de mayusculas se pueden especificar utilizando el parametro \code{case}.

Los caracteres acentuados se transliteran a ASCII.  Por ejemplo, una "o" con una
dieresis alemana sobre ella se convierte en "o", y el caracter español "ñ" se convierte en
"n".

Esta funcion toma y devuelve un data.frame. Se puede usar con pipelines
\code{`\%>\%`}. \code{limpiar_nombres} se basa en la versatil funcion
\code{link[snakecase]{to_any_case}}, que acepta muchos argumentos.  Consulte la documentacion de
esa funcion para obtener ideas sobre como sacar
sacar el maximo provecho de \code{limpiar_nombres}.  A continuacion se incluyen algunos ejemplos.

Esta funcion fue tomada del paquete janitor: \code{link[janitor]{clean_names}}.
}
\details{
\code{limpiar_nombres()} esta destinado a ser utilizado en \code{data.frames}
y objetos similares a un \code{data.frame}. Para limpiar otros objetos con nombre como listas con
nombre y vectores, use \code{limpiar_nombres2()}.
}
\examples{

# --- uso ---
#x <- data.frame(caseID = 1, DOB = 2, Other = 3)
#limpiar_nombres(x)

# o usando pipelines:
# x \%>\%
#  limpiar_nombres()

# si prefiere los nombres de las variables en camelCase:
#x \%>\%
 # limpiar_nombres(., "lower_camel")

# (not run) correr limpiar_nombres despues de cargar una base:
# library(readxl)
# read_excel("messy_excel_file.xlsx") \%>\%
#   limpiar_nombres()

# --- Aprovechando las ventajas de snakecase::to_any_case arguments ---

# Restaurar nombres de columnas para graficar
#mtcars \%>\%
#  limpiar_nombres(case = "title")

# indicar a limpiar_nombres dejar intactas ciertas abreviaturas:
#x \%>\%
#  limpiar_nombres(case = "upper_camel", abbreviations = c("ID", "DOB"))
}
\seealso{
Other Set names: 
\code{\link{mu_to_u}}
}
\concept{Set names}
