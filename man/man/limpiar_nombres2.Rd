% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/limpiar_nombres2.R
\encoding{UTF-8}
\name{limpiar_nombres2}
\alias{limpiar_nombres2}
\title{Limpia un vector de texto, que suele contener los nombres de un objeto.}
\usage{
limpiar_nombres2(
  string,
  case = "snake",
  replace = c(`'` = "", `"` = "", `\%` = "_percent_", `#` = "_number_"),
  ascii = TRUE,
  use_make_names = TRUE,
  sep_in = "\\\\.",
  transliterations = "Latin-ASCII",
  parsing_option = 1,
  numerals = "asis",
  ...
)
}
\arguments{
\item{string}{Un vector de caracteres de nombres para limpiar.}

\item{case}{Preferencias de mayusculas}

\item{replace}{Un vector de caracteres con nombre en el que el nombre se sustituye por el
value.}

\item{ascii}{Convertir los nombres a ASCII (TRUE, por defecto) o no (FALSE).}

\item{use_make_names}{¿Deberia aplicarse el codigo {make.names()} para asegurar que la sea utilizable como un nombre sin comillas?  (Evitar \code{make.names()} asegura que la salida es independiente de la localizacion, pero las comillas pueden ser necesarias).}

\item{sep_in}{(abreviatura de entrada separadora) si es un carácter, se interpreta como una expresión regular (envuelta internamente en stringr::regex()). El valor por defecto es una expresión regular que coincide con cualquier secuencia de valores no alfanuméricos. Todas las coincidencias serán reemplazadas por guiones bajos (además de "_" y " ", para los que esto siempre es cierto, incluso si se proporciona NULL). Estos guiones bajos se utilizan internamente para dividir las cadenas en subcadenas y especificar los límites de las palabras.}

\item{transliterations}{Un vector de caracteres (si no es NULL). Las entradas de este argumento deben ser elementos de stringi::stri_trans_list() (como "Latin-ASCII", que suele ser útil) o nombres de tablas de búsqueda (actualmente sólo se admite "german").}

\item{parsing_option}{Un entero que determinará la parsing_option.}

\item{numerals}{Carácter que especifica la alineación de los numerales ("medio", izquierda, derecha, asis o apretado). Es decir, numerales = "izquierda" garantiza que no haya ningún separador de salida delante de un dígito.}

\item{...}{...}
}
\value{
Devuelve el vector de caracteres "limpio".
}
\description{
Los vectores resultantes son unicos y estan formadas unicamente por el caracter
\code{_}, numeros y letras. Por defecto, solo consistiran en caracteres ASCII, pero se puede
permitir que no sean ASCII (por ejemplo, Unicode) configurando \code{ascii=FALSE}.
Las preferencias de mayusculas pueden especificarse utilizando el parametro \code{case}.

Cuando \code{ascii=TRUE} (el valor predeterminado), los caracteres acentuados se transliteran
a ASCII.  Por ejemplo, una "o" con dieresis alemana se convierte en "o", y
el caracter español "enye" se convierte en "n".
Esta funcion fue tomada del paquete janitor.
}
\examples{

# limpiar los nombres de un vector:
x <- structure(1:3, names = c("nombre con espacio", "DosPalabras", "total $ (2009)"))
x
names(x) <- limpiar_nombres2(names(x))
x # Ya tiene los nombres limpios

}
\seealso{
\code{\link[snakecase]{to_any_case}()}
}
